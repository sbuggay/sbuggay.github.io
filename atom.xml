<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>devanbuggay</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="sbuggay.github.io/"/>
  <updated>2018-01-29T05:37:51.850Z</updated>
  <id>sbuggay.github.io/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>id Tech 1 Maps in UE4 Part 1: Parsing WAD Map Data</title>
    <link href="sbuggay.github.io/2017/10/04/parsing-idtech1-ue4-p1/"/>
    <id>sbuggay.github.io/2017/10/04/parsing-idtech1-ue4-p1/</id>
    <published>2017-10-04T17:59:17.000Z</published>
    <updated>2018-01-29T05:37:51.850Z</updated>
    
    <content type="html"><![CDATA[<p>The map data serialization for Doom 1/2 is pretty well outlined here on the <a href="http://doom.wikia.com/wiki/WAD" target="_blank" rel="external">Doom wikia</a>. Game data (including map information) is stored in WAD (Where’s All the Data?) files. If you want to follow along with a DOOM 1 or DOOM 2 WAD you will need to purchase the games as the game data is not freeware. If not you could try parsing something like <a href="https://freedoom.github.io" target="_blank" rel="external">Freedoom</a>.</p><p>It follows the following format:</p><p>The header struct, refered to as <code>wadinfo_t</code>:</p><table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>0x00</td><td>4</td><td>identification</td><td>“PWAD” or “IWAD”</td></tr><tr><td>0x04</td><td>4</td><td>numlumps</td><td>Number of lumps in WAD</td></tr><tr><td>0x08</td><td>4</td><td>infotableofs</td><td>Offset of infotable</td></tr></tbody></table><p>The directory struct, refered to as <code>filelump_t</code>:</p><table><thead><tr><th>Offset</th><th>Size</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>0x00</td><td>4</td><td>filepos</td><td>Pointer to the start of the data in the WAD</td></tr><tr><td>0x04</td><td>4</td><td>size</td><td>Size of lump in bytes</td></tr><tr><td>0x08</td><td>8</td><td>name</td><td>String for lumps name. If shorter than 8 bytes must be padded to 8</td></tr></tbody></table><p>We will respresents these two structures like this:</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">header_t</span> &#123;</span></div><div class="line">    <span class="keyword">char</span> id[<span class="number">4</span>];</div><div class="line">    <span class="keyword">int</span> numlumps;</div><div class="line">    <span class="keyword">int</span> infotableofs;</div><div class="line">&#125; <span class="keyword">header_t</span>;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">directory_t</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> filepos;</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line">    <span class="keyword">char</span> name[<span class="number">8</span>];</div><div class="line">&#125; <span class="keyword">directory_t</span>;</div></pre></td></tr></table></figure><p>Lets load our WAD into memory and read in the header:</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line">FILE *wad = fopen(<span class="string">"DOOM2.WAD"</span>, <span class="string">"rb"</span>);</div><div class="line"></div><div class="line"><span class="keyword">header_t</span> header;</div><div class="line">fread(&amp;header, <span class="keyword">sizeof</span>(<span class="keyword">header_t</span>), <span class="number">1</span>, wad);</div></pre></td></tr></table></figure><p>With our header read in we get some information on the structure itself. <code>id</code> should be either <code>&quot;IWAD&quot;</code> (for Internal WAD) or <code>&quot;PWAD&quot;</code> (Used for expansions or modding.) <code>numlumps</code> will be how many lump directories we have with <code>infotableofs</code> being the offset of where this list starts in memory. Now we can start reading in our lumps:</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Allocate space for our lumps</span></div><div class="line"><span class="keyword">directory_t</span> *lumps = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">directory_t</span>) * header.numlumps);</div><div class="line"></div><div class="line"><span class="comment">// Move the file head to the infotable offset</span></div><div class="line">fseek(wad, header.infotableofs, SEEK_SET);</div><div class="line"><span class="comment">// Read them in</span></div><div class="line">fread(lumps, <span class="keyword">sizeof</span>(<span class="keyword">directory_t</span>), header.numlumps, wad);</div></pre></td></tr></table></figure><p>Lets iterate over the first 20 to see what we have to work with.</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">directory_t</span> *lump = lumps;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%.8s (%d) [%d]\n"</span>, lump-&gt;name, lump-&gt;filepos, lump-&gt;size);</div><div class="line">    lump++;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Here is the output:</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">PLAYPAL (12) [10752]</div><div class="line">COLORMAP (10764) [8704]</div><div class="line">ENDOOM (19468) [4000]</div><div class="line">DEMO1 (23468) [4834]</div><div class="line">DEMO2 (28304) [8018]</div><div class="line">DEMO3 (36324) [17898]</div><div class="line">MAP01 (54224) [0]</div><div class="line">THINGS (54224) [690]</div><div class="line">LINEDEFS (54916) [5180]</div><div class="line">SIDEDEFS (60096) [15870]</div><div class="line">VERTEXES (75968) [1532]</div><div class="line">SEGS (77500) [7212]</div><div class="line">SSECTORS (84712) [776]</div><div class="line">NODES (85488) [5404]</div><div class="line">SECTORS (90892) [1534]</div><div class="line">REJECT (92428) [436]</div><div class="line">BLOCKMAP (92864) [6418]</div><div class="line">MAP02 (99284) [0]</div><div class="line">THINGS (99284) [1730]</div><div class="line">LINEDEFS (101016) [7322]</div></pre></td></tr></table></figure><p>The first six are:</p><ul><li><a href="http://doom.wikia.com/wiki/PLAYPAL" target="_blank" rel="external">PLAYPAL</a> - Color palettes</li><li><a href="http://doom.wikia.com/wiki/COLORMAP" target="_blank" rel="external">COLORMAP</a> - Brighness values</li><li><a href="http://doom.wikia.com/wiki/ENDOOM" target="_blank" rel="external">ENDOOM</a> - Text to display when DOOM exits</li><li><a href="http://doom.wikia.com/wiki/Demo" target="_blank" rel="external">DEMOX</a> - Demo data</li></ul><p>After that we get to what we are actually interested in, a map marker.</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">MAP01 (54224) [0]</div></pre></td></tr></table></figure><p>Notice that the size of this lump is <code>0</code>. This is not always true for WADs though (games like Hexen actually use this space to store data in.) A better test is testing against the name, which must follow the format of: <code>ExMy</code> or <code>MAPxx</code> in the case of Doom.</p><p>What’s important is what comes after the map markers, these structures are always present:</p><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">THINGS (54224) [690]</div><div class="line">LINEDEFS (54916) [5180]</div><div class="line">SIDEDEFS (60096) [15870]</div><div class="line">VERTEXES (75968) [1532]</div><div class="line">SEGS (77500) [7212]</div><div class="line">SSECTORS (84712) [776]</div><div class="line">NODES (85488) [5404]</div><div class="line">SECTORS (90892) [1534]</div><div class="line">REJECT (92428) [436]</div><div class="line">BLOCKMAP (92864) [6418]</div></pre></td></tr></table></figure><p>The only ones we need to concern ourselves with are:</p><ul><li>THINGS</li><li>LINEDEFS</li><li>SIDEDEFS</li><li>VERTEXES</li><li>SECTORS</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The map data serialization for Doom 1/2 is pretty well outlined here on the &lt;a href=&quot;http://doom.wikia.com/wiki/WAD&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
      <category term="c" scheme="sbuggay.github.io/tags/c/"/>
    
      <category term="ue4" scheme="sbuggay.github.io/tags/ue4/"/>
    
  </entry>
  
  <entry>
    <title>ASCII Lockpicking</title>
    <link href="sbuggay.github.io/2017/09/22/ascii-lockpicking/"/>
    <id>sbuggay.github.io/2017/09/22/ascii-lockpicking/</id>
    <published>2017-09-22T21:51:06.000Z</published>
    <updated>2018-01-29T05:31:45.492Z</updated>
    
    <content type="html"><![CDATA[<p>A while back I worked on a roguelike with a serial killer theme. Here is an in-game gif of the lockpicking mechanic.<br>(With the pin ordering being shown for debug purposes.)</p><p><img src="/images/lockpick.gif" alt="lockpick"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A while back I worked on a roguelike with a serial killer theme. Here is an in-game gif of the lockpicking mechanic.&lt;br&gt;(With the pin ord
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C Garbage Collection Part 1: Finding the stack</title>
    <link href="sbuggay.github.io/2017/09/12/c-garbage-collection/"/>
    <id>sbuggay.github.io/2017/09/12/c-garbage-collection/</id>
    <published>2017-09-12T21:22:23.000Z</published>
    <updated>2018-01-29T05:33:06.716Z</updated>
    
    <content type="html"><![CDATA[<p>The simplest garbage collection pattern is mark and sweep. Implementing this in C we need to check 3 data segments for references to allocated memory. The stack, the heap, and .bss. In this post we will take a look at find where the stack exists in memory so we can scan it. There are platform specific ways to find this information, but this solution is platform agnostic.</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">size_t</span> top_of_stack;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stack_depth</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> bottom_of_stack;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"stack depth: %lu\n"</span>, top_of_stack - (<span class="keyword">size_t</span>) &amp;bottom_of_stack)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sentinal;</div><div class="line">    top_of_stack = (<span class="keyword">size_t</span>) &amp;sentinal;</div><div class="line"></div><div class="line">    print_stack_depth();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://web.engr.illinois.edu/~maplant2/gc.html" target="_blank" rel="external">http://web.engr.illinois.edu/~maplant2/gc.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The simplest garbage collection pattern is mark and sweep. Implementing this in C we need to check 3 data segments for references to allo
      
    
    </summary>
    
    
      <category term="c" scheme="sbuggay.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>C sizeof and  offsetof Implementation</title>
    <link href="sbuggay.github.io/2017/09/12/sizeof/"/>
    <id>sbuggay.github.io/2017/09/12/sizeof/</id>
    <published>2017-09-12T21:22:07.000Z</published>
    <updated>2018-01-16T03:53:45.916Z</updated>
    
    <content type="html"><![CDATA[<p>C has no internal reflection. Which basically means that given a raw pointer there is no way to infer anything about it at runtime. We can’t know if it’s size, what type it is, etc. If it’s a struct we don’t even know </p><p>The C <code>sizeof</code> macro.</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> sizeof(t) (char *)(&amp;t + 1) - (char *)(&amp;t)</span></div></pre></td></tr></table></figure><p>The C <code>offset</code> macro.</p><figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(t, m) (size_t)&amp;(((t *)0)-&gt;m)</span></div></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://en.wikipedia.org/wiki/Sizeof" target="_blank" rel="external">https://en.wikipedia.org/wiki/Sizeof</a></li><li><a href="https://barrgroup.com/Embedded-Systems/How-To/C-Offsetof-Macro" target="_blank" rel="external">https://barrgroup.com/Embedded-Systems/How-To/C-Offsetof-Macro</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;C has no internal reflection. Which basically means that given a raw pointer there is no way to infer anything about it at runtime. We ca
      
    
    </summary>
    
    
      <category term="c" scheme="sbuggay.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Hashing Windows Processes and Modules</title>
    <link href="sbuggay.github.io/2016/12/11/hashing-processes/"/>
    <id>sbuggay.github.io/2016/12/11/hashing-processes/</id>
    <published>2016-12-11T22:04:59.000Z</published>
    <updated>2018-01-29T05:34:26.720Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Enumerating-Process-List"><a href="#Enumerating-Process-List" class="headerlink" title="Enumerating Process List"></a>Enumerating Process List</h3><h3 id="Enumerating-Modules-of-a-Process"><a href="#Enumerating-Modules-of-a-Process" class="headerlink" title="Enumerating Modules of a Process"></a>Enumerating Modules of a Process</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://msdn.microsoft.com/en-us/library/ms686832%28VS.85%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="external">https://msdn.microsoft.com/en-us/library/ms686832%28VS.85%29.aspx?f=255&amp;MSPPError=-2147217396</a></li><li><a href="http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5" target="_blank" rel="external">http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Enumerating-Process-List&quot;&gt;&lt;a href=&quot;#Enumerating-Process-List&quot; class=&quot;headerlink&quot; title=&quot;Enumerating Process List&quot;&gt;&lt;/a&gt;Enumerating Pr
      
    
    </summary>
    
    
      <category term="c++" scheme="sbuggay.github.io/tags/c/"/>
    
      <category term="windows" scheme="sbuggay.github.io/tags/windows/"/>
    
  </entry>
  
</feed>
